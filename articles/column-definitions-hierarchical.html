<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Column Definitions: Hierarchical Columns | ProDataGrid for Avalonia </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Column Definitions: Hierarchical Columns | ProDataGrid for Avalonia ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/wieslawsoltes/ProDataGrid/blob/master/docfx/articles/column-definitions-hierarchical.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="column-definitions-hierarchical-columns">Column Definitions: Hierarchical Columns</h1>

<p>Column definitions work with hierarchical grids by binding to <code>HierarchicalNode</code> and using <code>DataGridHierarchicalColumnDefinition</code> for the expander column. This keeps the column model in your view model while still supporting fast-path sorting, filtering, and searching.</p>
<h2 id="define-columns-for-hierarchical-nodes">Define columns for hierarchical nodes</h2>
<p>Define bindings against <code>HierarchicalNode</code> and project to your item type. The accessor generated by <code>DataGridBindingDefinition</code> is used by fast-path models.</p>
<pre><code class="lang-csharp">private static DataGridBindingDefinition CreateNodeBinding&lt;TValue&gt;(string name, Func&lt;TreeItem, TValue&gt; getter)
{
    return ColumnDefinitionBindingFactory.CreateBinding&lt;HierarchicalNode, TValue&gt;(
        name,
        node =&gt; getter((TreeItem)node.Item));
}

_nameColumn = new DataGridHierarchicalColumnDefinition
{
    Header = &quot;Item&quot;,
    Binding = CreateNodeBinding&lt;TreeItem&gt;(&quot;Item&quot;, item =&gt; item),
    CellTemplateKey = &quot;HierarchyNameTemplate&quot;,
    SortMemberPath = &quot;Item.Name&quot;,
    Width = new DataGridLength(2, DataGridLengthUnitType.Star)
};

_idColumn = new DataGridTextColumnDefinition
{
    Header = &quot;Id&quot;,
    Binding = CreateNodeBinding&lt;int&gt;(&quot;Id&quot;, item =&gt; item.Id),
    SortMemberPath = &quot;Item.Id&quot;
};
</code></pre>
<p><code>SortMemberPath</code> is optional, but it helps map model descriptors back to columns when you want explicit ids or persistence.</p>
<h2 id="xaml-wiring">XAML wiring</h2>
<pre><code class="lang-xml">&lt;DataGrid ColumnDefinitionsSource=&quot;{Binding ColumnDefinitions}&quot;
          HierarchicalModel=&quot;{Binding Model}&quot;
          HierarchicalRowsEnabled=&quot;True&quot;
          SortingModel=&quot;{Binding SortingModel}&quot;
          FilteringModel=&quot;{Binding FilteringModel}&quot;
          SearchModel=&quot;{Binding SearchModel}&quot;
          SortingAdapterFactory=&quot;{StaticResource HierarchicalSortingAdapterFactory}&quot;
          FilteringAdapterFactory=&quot;{StaticResource AccessorFilteringAdapterFactory}&quot;
          SearchAdapterFactory=&quot;{StaticResource AccessorSearchAdapterFactory}&quot;
          AutoGenerateColumns=&quot;False&quot; /&gt;
</code></pre>
<p>The sorting adapter is optional; it is useful when you want header clicks to update the sorting model but apply sorting inside the hierarchical model instead of the flattened view. The accessor adapter factory names are examples; implement them in your app to avoid reflection.</p>
<h2 id="sorting-in-hierarchical-models">Sorting in hierarchical models</h2>
<p>Hierarchical grids should sort siblings in the model instead of reordering the flattened view. Use the sorting model to collect descriptors, then apply a comparer to the hierarchical model:</p>
<pre><code class="lang-csharp">private void OnSortingChanged(object sender, SortingChangedEventArgs e)
{
    var comparers = BuildComparers(e.NewDescriptors);
    var composite = Comparer&lt;TreeItem&gt;.Create((x, y) =&gt;
    {
        foreach (var entry in comparers)
        {
            var result = entry.Comparer.Compare(x, y);
            if (result != 0)
            {
                return entry.Direction == ListSortDirection.Descending ? -result : result;
            }
        }
        return 0;
    });

    Model.ApplySiblingComparer(composite, recursive: true);
}
</code></pre>
<p>If you handle sorting in the model, use a sorting adapter that short-circuits view sorting.</p>
<h2 id="filtering-while-keeping-parents">Filtering while keeping parents</h2>
<p>Hierarchical filters often keep ancestor nodes of matches so users can see the path. Build a match set and use a custom predicate:</p>
<pre><code class="lang-csharp">var matches = BuildMatchSet(RootItems, filterText);
FilteringModel.SetOrUpdate(new FilteringDescriptor(
    columnId: _nameColumn,
    @operator: FilteringOperator.Custom,
    predicate: item =&gt; MatchesFilter(item, matches)));
</code></pre>
<p>Use an accessor-based filtering adapter so filtering does not fall back to reflection.</p>
<h2 id="searching-and-highlights">Searching and highlights</h2>
<p>Search uses column text. Supply a text provider or ensure <code>ToString()</code> returns a useful value for hierarchical items:</p>
<pre><code class="lang-csharp">DataGridColumnSearch.SetTextProvider(_nameColumn, item =&gt; ((TreeItem)item).Name);
</code></pre>
<p>With a search adapter that uses value accessors, search remains reflection-free and supports highlights.</p>
<h2 id="streaming-updates">Streaming updates</h2>
<p>For frequent updates, use observable root collections and keep the hierarchical model as the source of truth. When updates change values that affect sorting or filtering, reapply the model logic (for example, re-run <code>ApplySiblingComparer</code>).</p>
<h2 id="related-articles">Related articles</h2>
<ul>
<li><a href="column-definitions.html">Column Definitions</a></li>
<li><a href="column-definitions-models.html">Column Definitions (Model Integration)</a></li>
<li><a href="column-definitions-hot-path.html">Column Definitions (Hot Path Integration)</a></li>
<li><a href="column-definitions-fast-path-overview.html">Column Definitions: Fast Path Overview</a></li>
<li><a href="hierarchical-data.html">Hierarchical Data</a></li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/wieslawsoltes/ProDataGrid/blob/master/docfx/articles/column-definitions-hierarchical.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
