# Columns and Editing

ProDataGrid supports a wide range of built-in columns, flexible sizing, auto-generation, and strong binding support. Editing is built in and can be combined with validation rules and row operations.

## Basic Setup

Basic layout with common column types and width modes (pixel, auto, star):

```xml
<DataGrid ItemsSource="{Binding People}"
          AutoGenerateColumns="False"
          CanUserResizeColumns="True"
          GridLinesVisibility="Horizontal">
  <DataGrid.Columns>
    <!-- Pixel width -->
    <DataGridTextColumn Header="ID"
                        Binding="{Binding Id}"
                        Width="60" />

    <!-- Auto sizes to content -->
    <DataGridTextColumn Header="Name"
                        Binding="{Binding Name}"
                        Width="Auto" />

    <!-- Fixed pixel width checkbox column -->
    <DataGridCheckBoxColumn Header="Active"
                            Binding="{Binding IsActive}"
                            Width="80" />

    <!-- Star sizing shares remaining space -->
    <DataGridTextColumn Header="Department"
                        Binding="{Binding Department}"
                        Width="*" />

    <!-- Template column with custom content and weighted star width -->
    <DataGridTemplateColumn Header="Notes"
                            Width="2*">
      <DataGridTemplateColumn.CellTemplate>
        <DataTemplate>
          <TextBlock Text="{Binding Notes}"
                     TextWrapping="Wrap" />
        </DataTemplate>
      </DataGridTemplateColumn.CellTemplate>
    </DataGridTemplateColumn>
  </DataGrid.Columns>
</DataGrid>
```

Widths accept pixel values (`"80"`), `Auto` (content-based), `*` or weighted stars (e.g., `2*`) that share remaining space.

## Column Sizing and Layout

- Widths: pixel, `Auto`, and star sizing (`*`, `2*`).
- Constraints: `MinWidth`/`MaxWidth` per column.
- Interaction: `CanUserResizeColumns`, `CanUserResizeColumnsOnDoubleClick`, and `CanUserReorderColumns` at the grid level; `CanUserResize`, `CanUserReorder`, and `CanUserSort` per column.
- Frozen columns: `FrozenColumnCount` and `FrozenColumnCountRight` pin columns on the left/right.

Double-click the column header resize handle to fit the column to visible content when `CanUserResizeColumnsOnDoubleClick` is enabled.

```xml
<DataGrid FrozenColumnCount="1"
          FrozenColumnCountRight="1"
          CanUserResizeColumns="True"
          CanUserReorderColumns="True" />
```

## Headers, Sorting, and Filters

Columns expose header content and sorting metadata:

- `Header` and `HeaderTemplate` define the column header content.
- `SortMemberPath` controls which property is sorted when the header is clicked.
- `SortDirection` can be set to seed an initial sort glyph.
- `ShowFilterButton` and `FilterFlyout` control the built-in filter glyph and flyout entry point.

Filter glyphs are driven by the filtering model; see [Data Operations](data-operations.md).

## Auto-Generated and Bindable Columns

- Turn on `AutoGenerateColumns` to build columns from the data model.
- Use `AutoGeneratingColumn` to customize headers, widths, and bindings.
- Build or replace the `Columns` collection at runtime for dynamic layouts.

Bind `Columns` to an `ObservableCollection<DataGridColumn>` to drive columns from a view-model. Control synchronization and placement when auto-generated columns are also enabled:

- `ColumnsSynchronizationMode`: `OneWayToGrid` (default) or `TwoWay` to mirror grid structural changes back to the source.
- `ColumnsSourceResetBehavior`: `Reload` or `Ignore` reset notifications from the source.
- `AutoGeneratedColumnsPlacement`: `AfterSource`, `BeforeSource`, or `None` when a columns source is set.

```xml
<DataGrid ItemsSource="{Binding Items}"
          Columns="{Binding Columns}"
          ColumnsSynchronizationMode="TwoWay"
          ColumnsSourceResetBehavior="Reload"
          AutoGeneratedColumnsPlacement="AfterSource"
          AutoGenerateColumns="True"
          HeadersVisibility="All" />
```

## Editing and Row Operations

- `IsReadOnly` on the grid or column disables editing.
- Editing lifecycle: `BeginningEdit`, `PreparingCellForEdit`, `CellEditEnding`, `CellEditEnded`, `RowEditEnding`, `RowEditEnded`.
- Programmatic flow: `BeginEdit`, `CommitEdit`, `CancelEdit`.
- `CanUserAddRows` and `CanUserDeleteRows` enable add/delete when the collection view supports it.
- `DataGridTemplateColumn.NewRowCellTemplate` lets you customize cells in the new-row placeholder.

Validation integrates with Avalonia validation rules and per-column settings. See [Validation and Errors](validation-and-errors.md).

## Template Columns

`DataGridTemplateColumn` gives full control over display and editing:

```xml
<DataGridTemplateColumn Header="Notes" Width="2*">
  <DataGridTemplateColumn.CellTemplate>
    <DataTemplate>
      <TextBlock Text="{Binding Notes}" TextWrapping="Wrap" />
    </DataTemplate>
  </DataGridTemplateColumn.CellTemplate>
  <DataGridTemplateColumn.CellEditingTemplate>
    <DataTemplate>
      <TextBox Text="{Binding Notes}" AcceptsReturn="True" />
    </DataTemplate>
  </DataGridTemplateColumn.CellEditingTemplate>
</DataGridTemplateColumn>
```

## DataTable Binding

When binding to `DataTable.DefaultView`, ProDataGrid binds cells via `TypeDescriptor` so you do not need manual indexers.

## Custom Columns

Derive from a built-in column to customize element creation while still reusing the grid's theme resources:

```csharp
using Avalonia.Controls;

public class AccentTextColumn : DataGridTextColumn
{
    protected override Control GenerateElement(DataGridCell cell, object dataItem)
    {
        var textBlock = (TextBlock)base.GenerateElement(cell, dataItem);
        if (CellTextBlockTheme is { } theme)
        {
            textBlock.Theme = theme;
        }

        return textBlock;
    }
}
```

## Column Types Reference

For a catalog of built-in column types and their main properties, see [Column Types Reference](column-types-reference.md).
