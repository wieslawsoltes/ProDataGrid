// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

#nullable disable

using Avalonia.Controls.Primitives;
using Avalonia.Data;
using Avalonia.Layout;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace Avalonia.Controls
{
    /// <summary>
    /// Layout and measurement
    /// </summary>
#if !DATAGRID_INTERNAL
public
#else
internal
#endif
    partial class DataGrid
    {

        /// <summary>
        /// Arranges the content of the <see cref="T:Avalonia.Controls.DataGridRow" />.
        /// </summary>
        /// <param name="finalSize">
        /// The final area within the parent that this element should use to arrange itself and its children.
        /// </param>
        /// <returns>
        /// The actual size used by the <see cref="T:Avalonia.Controls.DataGridRow" />.
        /// </returns>
        protected override Size ArrangeOverride(Size finalSize)
        {
            if (_makeFirstDisplayedCellCurrentCellPending)
            {
                MakeFirstDisplayedCellCurrentCell();
            }

            if (Bounds.Width != finalSize.Width)
            {
                // If our final width has changed, we might need to update the filler
                InvalidateColumnHeadersArrange();
                InvalidateCellsArrange();
            }

            return base.ArrangeOverride(finalSize);
        }


        /// <summary>
        /// Measures the children of a <see cref="T:Avalonia.Controls.DataGridRow" /> to prepare for
        /// arranging them during the
        /// <see cref="M:Avalonia.Controls.DataGridRow.ArrangeOverride(System.Windows.Size)" /> pass.
        /// </summary>
        /// <returns>
        /// The size that the <see cref="T:Avalonia.Controls.DataGridRow" /> determines it needs during layout, based on its calculations of child object allocated sizes.
        /// </returns>
        /// <param name="availableSize">
        /// The available size that this element can give to child elements. Indicates an upper limit that
        /// child elements should not exceed.
        /// </param>
        protected override Size MeasureOverride(Size availableSize)
        {
            // Delay layout until after the initial measure to avoid invalid calculations when the
            // DataGrid is not part of the visual tree
            if (!_measured)
            {
                _measured = true;

                // We don't need to clear the rows because it was already done when the ItemsSource changed
                RefreshRowsAndColumns(clearRows: false);

                //// Update our estimates now that the DataGrid has all of the information necessary
                UpdateRowDetailsHeightEstimate();

                // Update frozen columns to account for columns added prior to loading or autogenerated columns
                if (FrozenColumnCountWithFiller > 0 || FrozenColumnCountRightEffective > 0)
                {
                    ProcessFrozenColumnCount();
                }
            }

            Size desiredSize;
            // This is a shortcut to skip layout if we don't have any columns
            if (ColumnsInternal.VisibleEdgedColumnsWidth == 0)
            {
                HideLegacyScrollBars();
                desiredSize = base.MeasureOverride(availableSize);
            }
            else
            {
                if (_rowsPresenter != null)
                {
                    _rowsPresenter.InvalidateMeasure();
                }

                InvalidateColumnHeadersMeasure();

                desiredSize = base.MeasureOverride(availableSize);

                ComputeScrollBarsLayout();
                _rowsPresenter?.TrimRecycledContainers();
            }

            return desiredSize;
        }


        // Makes sure horizontal layout is updated to reflect any changes that affect it
        private void EnsureHorizontalLayout()
        {
            ColumnsInternal.EnsureVisibleEdgedColumnsWidth();
            InvalidateColumnHeadersMeasure();
            InvalidateRowsMeasure(true);
            InvalidateMeasure();
        }


        private void EnsureRowHeaderWidth()
        {
            if (AreRowHeadersVisible)
            {
                if (AreColumnHeadersVisible)
                {
                    EnsureTopLeftCornerHeader();
                }

                if (_rowsPresenter != null)
                {

                    bool updated = false;

                    foreach (Control element in _rowsPresenter.Children)
                    {
                        if (element is DataGridRow row)
                        {
                            // If the RowHeader resulted in a different width the last time it was measured, we need
                            // to re-measure it
                            if (row.HeaderCell != null && row.HeaderCell.DesiredSize.Width != ActualRowHeaderWidth)
                            {
                                row.HeaderCell.InvalidateMeasure();
                                updated = true;
                            }
                        }
                        else if (element is DataGridRowGroupHeader groupHeader && groupHeader.HeaderCell != null && groupHeader.HeaderCell.DesiredSize.Width != ActualRowHeaderWidth)
                        {
                            groupHeader.HeaderCell.InvalidateMeasure();
                            updated = true;
                        }
                    }

                    if (updated)
                    {
                        // We need to update the width of the horizontal scrollbar if the rowHeaders' width actually changed
                        InvalidateMeasure();
                    }
                }
            }
        }


        private void EnsureRowsPresenterVisibility()
        {
            if (_rowsPresenter != null)
            {
                // RowCount doesn't need to be considered, doing so might cause extra Visibility changes
                _rowsPresenter.IsVisible = (ColumnsInternal.FirstVisibleNonFillerColumn != null);
            }
        }


        private void EnsureTopLeftCornerHeader()
        {
            if (_topLeftCornerHeader != null)
            {
                _topLeftCornerHeader.IsVisible = (HeadersVisibility == DataGridHeadersVisibility.All);

                if (_topLeftCornerHeader.IsVisible)
                {
                    if (!double.IsNaN(RowHeaderWidth))
                    {
                        // RowHeaderWidth is set explicitly so we should use that
                        _topLeftCornerHeader.Width = RowHeaderWidth;
                    }
                    else if (VisibleSlotCount > 0)
                    {
                        // RowHeaders AutoSize and we have at least 1 row so take the desired width
                        _topLeftCornerHeader.Width = RowHeadersDesiredWidth;
                    }
                }
            }
        }


        private void EnsureColumnHeadersVisibility()
        {
            if (_columnHeadersPresenter != null)
            {
                _columnHeadersPresenter.IsVisible = AreColumnHeadersVisible;
            }
        }

        private void OnIsVisibleChanged(AvaloniaPropertyChangedEventArgs e)
        {
            if (e.NewValue is bool isVisible && !isVisible)
            {
                _scrollStateManager.Capture(preserveOnAttach: false);
                ResetDisplayedRows();
            }
        }


        private void EnsureVerticalGridLines()
        {
            if (AreColumnHeadersVisible)
            {
                double totalColumnsWidth = 0;
                foreach (DataGridColumn column in ColumnsInternal)
                {
                    totalColumnsWidth += column.ActualWidth;

                    column.HeaderCell.AreSeparatorsVisible = (column != ColumnsInternal.LastVisibleColumn || totalColumnsWidth < CellsWidth);
                }
            }

            foreach (DataGridRow row in GetAllRows())
            {
                row.EnsureGridLines();
            }
        }


        private void InvalidateCellsArrange()
        {
            foreach (DataGridRow row in GetAllRows())
            {
                row.InvalidateHorizontalArrange();
            }
        }


        private void InvalidateRowsArrange()
        {
            if (_rowsPresenter != null)
            {
                _rowsPresenter.InvalidateArrange();
            }
        }


        private void InvalidateColumnHeadersMeasure()
        {
            if (_columnHeadersPresenter != null)
            {
                EnsureColumnHeadersVisibility();
                _columnHeadersPresenter.InvalidateMeasure();
            }
        }


        private void InvalidateRowsMeasure(bool invalidateIndividualElements)
        {
            if (_rowsPresenter != null)
            {
                _rowsPresenter.InvalidateMeasure();

                if (invalidateIndividualElements)
                {
                    foreach (Control element in _rowsPresenter.Children)
                    {
                        element.InvalidateMeasure();
                    }
                }
            }
        }


        internal void InvalidateColumnHeadersArrange()
        {
            if (_columnHeadersPresenter != null)
            {
                _columnHeadersPresenter.InvalidateArrange();
            }
        }


        private void AddNewCellPrivate(DataGridRow row, DataGridColumn column)
        {
            DataGridCell newCell = new DataGridCell();
            PopulateCellContent(
                isCellEdited: false,
                dataGridColumn: column,
                dataGridRow: row,
                dataGridCell: newCell);
            if (row.OwningGrid != null)
            {
                newCell.OwningColumn = column;
                newCell.IsVisible = column.IsVisible;
                if (row.OwningGrid.CellTheme is {} cellTheme)
                {
                    newCell.SetValue(ThemeProperty, cellTheme, BindingPriority.Template);
                }
                if (_conditionalFormattingAdapter != null)
                {
                    var descriptor = _conditionalFormattingAdapter.MatchCell(row.DataContext, row.Index, column);
                    ApplyConditionalFormattingToCell(newCell, descriptor);
                }
            }
            row.Cells.Insert(column.Index, newCell);
        }


        private void CompleteCellsCollection(DataGridRow dataGridRow)
        {
            Debug.Assert(dataGridRow != null);
            int cellsInCollection = dataGridRow.Cells.Count;
            if (ColumnsItemsInternal.Count > cellsInCollection)
            {
                for (int columnIndex = cellsInCollection; columnIndex < ColumnsItemsInternal.Count; columnIndex++)
                {
                    AddNewCellPrivate(dataGridRow, ColumnsItemsInternal[columnIndex]);
                }
            }
        }

        private bool _measured;


        private void OnHeadersVisibilityChanged(AvaloniaPropertyChangedEventArgs e)
        {
            var oldValue = (DataGridHeadersVisibility)e.OldValue;
            var newValue = (DataGridHeadersVisibility)e.NewValue;
            bool hasFlags(DataGridHeadersVisibility value, DataGridHeadersVisibility flags) => ((value & flags) == flags);

            bool newValueCols = hasFlags(newValue, DataGridHeadersVisibility.Column);
            bool newValueRows = hasFlags(newValue, DataGridHeadersVisibility.Row);
            bool oldValueCols = hasFlags(oldValue, DataGridHeadersVisibility.Column);
            bool oldValueRows = hasFlags(oldValue, DataGridHeadersVisibility.Row);

            // Columns
            if (newValueCols != oldValueCols)
            {
                if (_columnHeadersPresenter != null)
                {
                    EnsureColumnHeadersVisibility();
                    if (!newValueCols)
                    {
                        _columnHeadersPresenter.Measure(default);
                    }
                    else
                    {
                        EnsureVerticalGridLines();
                    }
                    InvalidateMeasure();
                }
            }

            // Rows
            if (newValueRows != oldValueRows)
            {
                if (_rowsPresenter != null)
                {
                    foreach (Control element in _rowsPresenter.Children)
                    {
                        if (element is DataGridRow row)
                        {
                            row.EnsureHeaderStyleAndVisibility(null);
                            if (newValueRows)
                            {
                                row.ApplyState();
                                row.EnsureHeaderVisibility();
                            }
                        }
                        else if (element is DataGridRowGroupHeader rowGroupHeader)
                        {
                            rowGroupHeader.EnsureHeaderVisibility();
                        }
                    }
                    InvalidateRowHeightEstimate();
                    InvalidateRowsMeasure(invalidateIndividualElements: true);
                }
            }

            if (_topLeftCornerHeader != null)
            {
                _topLeftCornerHeader.IsVisible = newValueRows && newValueCols;
                if (_topLeftCornerHeader.IsVisible)
                {
                    _topLeftCornerHeader.Measure(default);
                }
            }

        }

        private void OnGridLinesVisibilityChanged(AvaloniaPropertyChangedEventArgs e)
        {
            foreach (DataGridRow row in GetAllRows())
            {
                row.EnsureGridLines();
                row.InvalidateHorizontalArrange();
            }
        }

        private void OnVerticalGridLinesBrushChanged(AvaloniaPropertyChangedEventArgs e)
        {
            if (_rowsPresenter != null)
            {
                foreach (DataGridRow row in GetAllRows())
                {
                    row.EnsureGridLines();
                }
            }
        }

        private void OnHorizontalGridLinesBrushChanged(AvaloniaPropertyChangedEventArgs e)
        {
            if (!_areHandlersSuspended && _rowsPresenter != null)
            {
                foreach (DataGridRow row in GetAllRows())
                {
                    row.EnsureGridLines();
                }
            }
        }

    }
}
